---
title: "VF1 Vignette"
author: "Cord Huchzermeyer"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(visualFields)

example1 <- vffilter(vfpwgSunyiu24d2, 
                     id == "sample1" & 
                       eye == "OD" & 
                       date == min(vfpwgSunyiu24d2$date))

# example1_dataframe <- data.frame(x = getlocmap()$coord$x, y = getlocmap()$coord$y, td = as.vector(unlist(example1[1, 11:64])))

```

The visualFields package facilitates statistical analysis and plotting of visual field data, focussing on static perimetry.

# What is visual field testing?

Visual field testing measures a patient's visual ability at different locations of the visual field. This ability is usually highest in the center of the visual field (i.e. the point that the observer looks at) and decreases toward the periphery (*hill of vision*). The most common type of visual field testing is *perimetry*, which is performed with in a dome-shaped cupule, so that the distance between the stimulus and the eye equal for all locations within the visual field. In contrast, *campimetry* is performed with a flat screen.

Usually, perimetry tests the ability to perceive differences in luminance with an achromatic (not colored) stimulus (white-on-white perimetry). However, theoretically, other aspects of vision can be tested at different locations (ability to discriminate dots that are very close to each other, ability to discriminate similar colors, contrast sensitivity). 

```{r echo=FALSE}

default_locmap <- getlocmap()

plot(x = default_locmap$coord$x, 
     y = default_locmap$coord$y, 
     type = "point", 
     asp = 1,
     xlim = c(-32, 26),
     ylim = c(-29, 26),
     yaxt = 'n',
     xaxt = 'n',
     bty = 'n',
     xlab = "",
     ylab = "")
text(x = 0, y = -28, "horizontal eccentricity [degree]")
text(x = -34, y = -0, "vertical eccentricity [degree]", srt = 90)
points(x = default_locmap$coord[default_locmap$bs, "x"],
       y = default_locmap$coord[default_locmap$bs, "y"],
       col = "red")
lines(x = c(-2.5, 2.5), y = c(0, 0))
lines(x = c(0, 0), y = c(-2.5, 2.5))

```

The visual fields package was created to analyze data from *static perimetry*, where a threshold is measured for each of a fixed number of locations in a grid pattern. In contrast, in *kinetic perimetry*, a light spot moves from the periphery toward the center along a number of meridians and the location there the spot is first perceivable for the subject is noted.

# Performing visual field tests

For the typical visual field test, the subject or patient is comfortably seated in front of a perimeter and puts his head on a chin rest looking into a white Ganzfeld cupule (or hemisphere). The perimeter is located in a dimly lit, calm room and the subject has been explained what to do by an experienced technician before the examination. In his hand, the subject has a button.

He now looks at a fixation light right in front of him in the center of the cupule and presses the button as soon as he sees a light appearing anywhere in the cupule. These lights are presented only for a short time span (typically 100-200ms), so that the subject has no time to shift his gaze to the stimulus. A press of the button will be linked to a presentation when it occurs within a given time window after the presentation. A computer will present stimuli several times at different locations in a grid pattern. For each location, the stimulus intensity (luminance) will be adjusted depending on the subjects responses, but the presentations will be randomly interleaved between different locations.

## Grid pattern

The spatial position of the points $l_1$ to $l_n$ in the visual field is found in the location map (locmap) and depends on the pattern used by the perimeter. When analyzing data, you need to specify the locmap.

By default, the 24-2 pattern (shown above) is used, which consists of 54 locations that are equally spaced across the field.

```{r}

# install.packages("visualFields")
library(visualFields)

default_locmap <- getlocmap()

str(default_locmap)

```

Beside a name and a description, a locmap dataset contains a coordinate table with the x- and y- coordinates of the locations measured in degrees, and the id of the points that cover the physiological blind spot (the id is the number x in $l_x$ and corresponds to the row in the coord table).

Locations of the locmap that cover the blind spot are reported in the locmaps lists under the variable bs. If the blind spot is outside the pattern (for example in the 10Â° visual fields) or is spared by the grid as in the Octopus G1 pattern, the list item bs is set to numeric(0).

```{r}

ten_two_locmap <- locmaps$p10d2

str(ten_two_locmap)

```
The grid, the stimulus size, presentation time and the algorithm responsible for varying intensities remain constant throughout the examination and are called a perimetry program. Not that examinations performed with different programs cannot be directly compared.

# Clinical applications of visual field tests

In clinical practice, visual field testing is used identify decreases in visual function caused by disease. Such *visual field defects* or *scotomas* can be caused by diseases that affect tissue anywhere along the optic pathway. This ranges from the optic media (cornea / lens / vitreous) which transmit light, over the retina which detects lights and preprocesses visual information, the optic nerve which transmits information, up to the brain. 

Often, clinicians can draw reliable conclusions about the localisation of the disease by the pattern of the visual field defects. For example, an infarction of the right visual cortex leads complete blindness in the left hemispheres of both eyes with a very distinct border along the vertical meridian. Therefore, the patient does not perceive anything to the right of the point they look at. On the other side of vertical meridian the visual field is normal. In contrast, patients with glaucoma start with areas of slightly perceived light sensitivity often in the upper or lower hemifield with a bow-shaped pattern cause by the localisation of damage in the optic nerve head.

Visual field tests can be used to diagnose disease, to appraise the functional consequences of disease (for example: can the patient still drive a vehicle?), and to monitor progression of disease.

The most advanced statistical methods have been created for monitoring glaucoma progression. The open-angle glaucomas are a group of slowly progressing, chronic neurodegenerative diseases of the optic nerve, often caused by increased eye pressure. Patients need consequent monitoring over many years and slight changes in the visual field must be detected reliably. Therefore, many of the functions of the visualField package focus on glaucoma research.

# Getting started with the package

## Loading data

The visualField package contains some example data. This dataset contains the results of 42 visual field tests of one patient (id: sample1). The patient has primary open-angle glaucoma (type: pwg).

```{r}

data(vfpwgSunyiu24d2)

str(vfpwgSunyiu24d2[, 1:10])

```

The first columns characterize the patient, the time and duration of the examination, the diagnosis, and the reliability parameters 'false positive responses', 'false negative responses' and 'fixation losses'.

Each row corresponds to one visual field test. Visual field testing is performed monocularly (one eye at a time), so that two examinations exist for each date. The abbreviations for the laterality ('eye')is derived from latin (OD: right eye = oculus dexter, and OS: left eye = oculus sinister), when both eyes are examined, the abbreviation is OU.

The environment variable locini contains the number of the first column that contains the actual visual field date. Each column $l_{n}$ corresponds to one location in the visual field test. A concise way to select the columns $l_1$ to $l_{n}$ is to use the *getvfcols* function.

```{r}

getlocini()
getvfcols()

vfpwgSunyiu24d2[1, getlocini():ncol(vfpwgSunyiu24d2)]

```

There mustn't be any columns after these columns. Use the *vffilter* function to select specific fields and teh *vfisvalid* function to check whether a table fulfills the criteria. The latter will also tell you what the problem is when it doesn't.

```{r}

example1 <- vffilter(vfpwgSunyiu24d2, 
                     id == "sample1" & 
                       eye == "OD")[1, ]

example1$newVariable <- "not valid"

vfisvalid(example1)

```


## Plotting the visual field

The most straightforward plots show the sensitivities at the corresponding locations. These representations are very exact, but may be difficult to interpret. For learning purposes, here, we manually plot some visual field data.

```{r}

setdefaults()

example2 <- vffilter(vfpwgSunyiu24d2, 
                     id == "sample1" & 
                       eye == "OD")[1, ]

vfisvalid(example2)

example2_dataframe <- data.frame(x = getlocmap()$coord$x, 
                                 y = getlocmap()$coord$y, 
                                 td = as.vector(unlist(example2[, getvfcols()])))

ggplot(example2_dataframe, aes(x = x, y = y)) +
  geom_text(aes(label = td)) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  theme_void()

```
Note that left eyes have to be treated differently if you plot the points manually, because the location labels are mirrored. 

By convention, when both eyes are presented side by side, the left eye is shown on the left and the right eye on the right. This corresponds to the visual field of the observer, so that the physiological blindspots are directed temporally (toward the temple, away from the nose) for both eyes. This is in contrast to presentation of structural data, which is usually shown like it would look in a patient sitting in front of you, where his right eye is on the observers left side.

```{r}

OD_dataframe <- data.frame(x = getlocmap()$coord$x, 
                             y = getlocmap()$coord$y, 
                             loc_label = paste0("l", 1:54),
                             is_blindspot = FALSE,
                             eye = "OD")

# Note the minus in the x variable for the left eye
OS_dataframe <- data.frame(x = -getlocmap()$coord$x, 
                             y = getlocmap()$coord$y, 
                             loc_label = paste0("l", 1:54),
                             is_blindspot = FALSE,
                             eye = "OS")

OD_dataframe[getlocmap()$bs, "is_blindspot"] <- TRUE
OS_dataframe[getlocmap()$bs, "is_blindspot"] <- TRUE

ODOS_dataframe <- rbind(OS_dataframe, OD_dataframe)

# Use factor in order to show left eye on the left side
ODOS_dataframe$eye <- factor(ODOS_dataframe$eye, 
                             levels = c("OS", "OD"), 
                             ordered = TRUE)


ggplot(ODOS_dataframe, aes(x = x, y = y)) +
  geom_label(aes(label = loc_label, color = is_blindspot)) +
  scale_color_manual(values = c("black", "red")) +
  facet_wrap(~ eye)


```


The visualField package provides functions for more sophisticated plotting, which will be explained later. *These functions automatically take care that right eyes and left eyes are plotted correctly.*

# Psychophysical testing

Psychophysical tests systematically measure the relationship between physical stimulus strength and the subjective perception. This is performed by varying the stimulus and asking the observer to communicate his perception with a limited number of allowed responses. In visual field testing, the observer usually presses a button when a light spot is perceived. 

The relationship between stimulus and perception is analyzed using mathematical model. Commonly, these models result in an estimate of a *threshold*, which denotes either the absolute stimulus strength that can just barely be perceived or the smallest difference that can be perceived as different. 

Real world scenarios where perception is close to threshold include going through a dark forest on a cloudy night or seeing the car in front through a dense fog. Stimuli are not clearly seen when close to threshold. For this reason, patients sometimes feel that lengthy visual field testing is tedious and that it is as an unreliable examination. The latter is not clearly correct when fluctuations are taken into account and data are analyzed with appropriate statistical methods.

# Measurements

Although usually not seen in visual field data, the most elementary unit of a static visual field test is a subject's response. It consists of the constant stimulus parameters (size, presentation time, background luminance), the stimulus location, the stimulus intensity and whether the subject pressed the button within a predefined time window to indicate that he saw the stimulus.

Below a certain *threshold* luminance, a stimulus is usually not perceivable, above the threshold, the stimulus is usually perceived. However, close to threshold, a stimulus is not always reliably perceived. By definition, the threshold is the luminance of the stimulus where the subject will see the stimulus with a probability of 50%.

The most straightforward to measure such a threshold would be to present stimuli several time at a number different, fixed stimulus strengths. This method is called the method of *constant stimuli* and results in the *psychometric function*, which is usually modeled with a cumulative distribution function (CDF), for example a Gaussian CDF. However, this is not the most effective way to estimate a threshold, because stimulus strength far from the threshold will have probabilities to be seen that are close to either 0% or 100%. Testing these strengths several times does not yield much information.

Therefore, advanced algorithms were developed for reducing the number of stimulus presentations with limited trade-off concerning the accuracy of the measurements. A staircase algorithm where the intensity is decreased by a certain step size when the stimulus was seen, increased when not seen, and the step size is halved upon each revearsal (seen to not seen or vice versa) is a more efficient algorithms that is frequently used. More efficient algorithms usually make a trade-off between precision of the threshold estimate and test time, and often incorporate information on responses in neighboring locations into the algorithm. Examples include the Swedish Interactive Threshold Algorithm (SITA) of the Humphery Perimeters. Note that long test times negatively affect attention and therefore both accuracy and precision of the threshold estimates.

## False negatives / positives

Residual deviation from the psychometric function may occur due to inattention of the observer but also due to short-term fluctuation of the threshold. For example, it has been shown that the threshold underlies short-term fluctuates in the areas where light sensitivity was negatively affected by glaucoma, a disease of the optic nerve.

When the observer does not see a stimulus that is clearly above a level that has been seen before, this is called a false negative response (fnr). In contrast, when the subject presses the button although no stimulus is presented, this is a false positive response (fpr).

The cooperation of the subject is also tested in some perimeters by presenting deliberately presenting a stimulus at the location of the blind spot. If the subjects sees that stimulus, it must be assumed that he did not fixate correctly (fixation loss) and that the reliability of the field is decreased.

# Mathematical derivatives of threshold

## Sensitivity and other mathematical derivatives of threshold

However, the data analyzed with the visual fields package usually consists of the subjects *differential light sensitivity* for a stimulus at a given location in decibel (dB) as the most elementary unit. This sensitivity is calculated from the psychophysical threshold, which is derived from the aforementioned responses at this location.

The light sensitivity [dB] is defined as $10*log_{10}{\frac{L_{max}}{L}}$. Where $L$ is the threshold luminance and $L_{max}$ is the maximal stimulus intensity the perimeter uses.

The light sensitivity fluctuates considerably between measurements in the same observer, between observers, but it also decreases with age.

## Defect / Deviation

Clinically it is often more interesting to map the deviation from a theoretical "normal" sensitivity than the absolute sensitivity, because this facilitates the identification of disease. Furthermore, a decline of DLS with age occurs also in normal subjects. Therefore, age-related normative date must be collected which results in a function the describes the relationship between DLS and age for each location in the visual field. This function is usually linear.

The resulting difference is also measured in dB and is called either *deviation* (loss of function has a negative sign; used in Humphrey perimeters) or *defect* (loss of function has a positive sign; used in Octopus perimeters). In this package, *deviation* is used, and it is called *total deviation*. Make sure that you get the right sign if you import data.

In eye diseases like glaucoma, general defects that affect the whole visual field are often less relevant than focal scotomas. Therefore, deviation is sometimes corrected for the average sensitivity of the visual field. This is called *pattern deviation*.

### Sensitivity

In the visualField datasets, $l_1$ to $l_n$ represents sensitivities.

```{r}

example2[, getlocini()+1:4]

```

### Total deviation

Total deviation is calculated from the sensitivities and from age-related normal values. These are saved in the environment variable *nv* (normal values).

```{r total deviation}

age <- example2[1, "age"]

print(age)

normal_values <- getnv()$agem$model(age)[1:4]

print(normal_values)

total_defects <- example2[, getlocini()+1:4] - normal_values

print(total_defects)

```

These values can be automatically calculated with a dedicated function.

```{r}

gettd(example2)[, getlocini()+1:4]

```


### Pattern deviation

The pattern deviation corrects for the mean deviation, i.e. the average sensitivity loss. It highlights local defects but does not show global sensitivity loss, for example due to opacification of the optic media.

```{r pattern deviation}

getpd(example2)[, getlocini()+1:4]

```

## Probabilities

Psychophysical values vary considerably between subjects, but they also fluctuate between measurements. Therefore, deviation will be different from zero most of the time, and the clinician has to know, if a given deviation is likely to be caused by disease, or whether it may just reflect normal variability.

This is calculated based on measurements in the reference population that is also used to calculate the normative data.

### Total deviation

```{r total deviation probabilities}

gettdp(example2)[, getlocini()+1:4]

```

### Pattern deviation

```{r pattern deviation probabilities}

getpdp(vfpwgSunyiu24d2)[1:4, 1:12]

```

# Plotting the visual field

There are different ways to visualize perimetric results. These visualizations have to be interpreted like maps in that they represent a simplified version of the hill of vision.

The standard already contains some additional information with a border presenting a color-coded visualization of the deviation and a graphical representation of the blind spot. Note that the vfplot with the option "td" needs information on differential light-sensitivities in a normal reference population and on the probability of given deviations from these normal values. These data are included for the typical Humphrey Field Analyzer fields, but you need to collect this information if you use other perimeters

```{r}

vfplot(example2, type = "s")

```

Note that you have to specify what type of data is contained in the visual field tables. The default is set to *total deviation*.

```{r}

vfplot(example2, type = "td")

```

```{r}

vfplot(example2, type = "tds")

```

```{r}

vfplot(example2, type = "pd")

```

```{r}

vfplot(example2, type = "pds")

```

# Global parameters

Global parameters summarize the visual field in a few parameters. These global parameters also can be calculated with the visualField package. The resulting table contains the visual field header data (patient id, eye, etc.), but contains 8 columns (msens, ssens, tmd, tsd, pmd, psd, gh, and vfi) instead.

The mean sensitivity (MS, msens) is the arithmetic mean of all sensitivity values, the mean deviation (MD, tmd) is the arithmetic mean of all total deviation values in the field. The pattern standard deviation (PSD) is the standard deviation of the total deviation values.

```{r}

getgl(example2)[, -(1:getlocini()-1)]

```
Again, the probability of the observed values given that the visual field is normal can be calculated.

```{r}

getglp(getgl(example2))[, -(1:getlocini()-1)]

```

# Structure function correlations in glaucoma patients

In the last years, techniques detailed imaging of the retina and the optic nerve have made incredible advances. Therefore, correlation between structure and function is becoming even more important than ever.

When photoreceptors are lost in an specific retinal area, the scotoma always occurs in the directions in space that is perceived by that retinal area. This makes structure-function correlations easy.

In glaucoma, the damage occurs in the optic nerve at the levels of the nerve fiber bundles, which consist of the axons of the retinal ganglion cells. In the retina, these cells form two layers: the ganglion cell layer that contains the cell bodies, and the retinal nerve fiber layer. However, the cell bodies of the retinal ganglion cells are displaced from the area where the photoreceptors are located that they receive input from. This displacement is relevant mostly in the center of the visual field.

Therefore, the visualFields package provides function to calculate where the ganglion cells that subserve a given location in the visual field are located and to calculate at which angle the axons of these ganglion cells enter the optic nerve head (optic disc), where they pass through the sclera (wall of the eye) to form the optic nerve.

```{r}

locmaps$p24d2$coord[23, ]

loc2psi(locmaps$p24d2$coord[23, ])

vf2gc(locmaps$p24d2$coord[23, ])

```

From the angle of incidence, the nerve fiber bundle path can be calculated. Note that the function for calculating the trajectory will extrapolate the trajectory beyond the location of the visual field (usually to the raphe).

```{r}

# use loc2psi to calculate the incidence of the nerve fiber corresponding to a given location at the ONH
angle_of_incidence_l19 <-loc2psi(locmaps$p24d2$coord[19, ])

# use cart2jpolar for calculating the position of the visual field location in the polar coordinate system
locations <- rbind(cart2jpolar(locmaps$p24d2$coord[19, ]),
                   cart2jpolar(locmaps$p24d2$coord[23, ]),
                   cart2jpolar(locmaps$p24d2$coord[47, ]),
                   cart2jpolar(data.frame(x = 0, y = 0)))
locations$labels <- c("l19", "l23", "l47", "fixation")

# use bundePath to create a function for calculating the bundle path
path_function_l19 <- bundlePath(angle_of_incidence_l19)
path_function_l23 <- bundlePath(loc2psi(locmaps$p24d2$coord[23, ]))
path_function_l47 <- bundlePath(loc2psi(locmaps$p24d2$coord[47, ]))

bundle_path <- data.frame(y = 0:90,
                          x_l19 = path_function_l19(0:90),
                          x_l23 = path_function_l23(0:90),
                          x_l47 = path_function_l47(0:90))

ggplot(bundle_path, aes(y = y)) +
  geom_line(aes(x = x_l19)) +
  geom_point(data = locations, aes(x = -psi, y = r, color = labels, shape = labels == "fixation")) +
  geom_line(aes(x = x_l23), color = "red") +
  geom_line(aes(x = x_l47), color = "blue") +
  coord_polar(start = pi / 2, direction = -1) +
  scale_x_continuous(breaks = c(-180, -90, 0, 90, 180), limits = c(-180, 180)) +
  scale_y_continuous(limits = c(0, 60)) +
  scale_color_manual(values = c("l19" = "black", "l23" = "red", "l47" = "blue", "fixation" = "black")) +
  guides(color = FALSE, shape = FALSE)

```

In this plot, the origin corresponds to the center of the ONH, the black triangle corresponds to the fovea, and the 180degree angle corrsponds to the line between the ONH center and the fovea, which is, in reality, slightly tilted downward in most patients.

# Longitudinal analyses

Monitoring function over time in glaucoma patients is the most common clinical application of visual fields in ophthalmology. 

For several reasons, measurements will fluctuate over time. Fluctuation between measurements will be higher in eyes with glaucoma, especially in areas of glaucoma-related visual field defects. Therefore, it is not possible to compare two field tests and claim that the disease has progressed only because the second test yields poorer sensitivities. 

Thus, statistical methods and a minimum number of tests are necessary in order to demonstrate disease progression in the visual fields. Statistical methods that can be subdivided into *event-based* and *trend-based* methods. Furthermore, methods can be subdivided into those that require datasets which describe the "normal fluctuation" in a given population, those that rely on a mathematical model of visual field progression, and those that do not rely on either.

Event-based methods are not implemented in the visualFields pacakge. Briefly, they look for progression between the most recent field and a baseline test. Progression is characterized by a decrease in sensitivity with a magnitude that is unlikely (< 5%) in the population under examination (population based data is necessary) and needs to be confirmed in further tests (usually at least two).

Trend-based methods assume that progression takes place more slowly, so that several field tests are carried out during this time span. This concept is unsettling for the clinician who wants to stop progression the first time that he sees the patient, but regularly takes place even in the case of optimal treatment. The advantage is that all measurements are taken into account, not only the baseline test and the most recent tests.

For the next example, we will select a series of 27 visual fields that were obtained over several years.

```{r}

example3 <- vffilter(vfpwgSunyiu24d2, 
                     id == "sample1" & 
                       eye == "OS")
```

## Plotting progression

The sparkline plot only shows the raw data.

```{r}

vfsparklines(example3)

```

The lego plot shows probabilities for progression which relies on population based data.

```{r}

vflegoplot(example3)

```

## Statistical analysis

Statistical analysis can be performed with linear regression of global parameters, pointwise linear regression (one regression line for each location), which results in a number of p-values, or with Permutation analysis of Pointwise Linear Regression (PoPLR).

The *glr* function performs linear regression on global parameters. In the following example, the patient loses 0.24dB each year and this change is statistically significant.

```{r}

md_regression <- data.frame(time = glr(getgl(example3), type = "md")$years,
           md = glr(getgl(example3), type = "md")$data)

slope <- glr(getgl(example3), type = "md")$sl
intercept <- glr(getgl(example3), type = "md")$int

ggplot(md_regression, aes(x = time, y =md)) +
  geom_point() +
  geom_abline(slope = slope, intercept = intercept)

glr(getgl(example3), type = "md")$pval

```

The *plr* function performs pointwise linear regression (i.e. linear regression for each location in the field separately). Specific parameters have to be chosen, in order to detect disease progression. For example, progression might be defined as at least 3 locations having a slope less than 0dB/year and a p-value less than 0.05.

```{r}

prog1 <- plr(example3)
str(prog1, max.level = 1)

print(sum(prog1$pval < 0.05))

vfplotplr(example3)

```

The *poplr* function performs pointwise linear regression, and then calculates an S-score on the visual field series and on random permutations of the series, in order to control the Type I error (diagnosing progression in a non-progressing series) without relying on population data or a mathematical model of progression. It is computationally intensive.

The *poplr* function yields a large list with many intermediate computations. The main result is the S-score and the probability of getting this S-score in the absence of progression (Type I error). Note that there is a left and a right probability (deterioration and improvement) in the current implementation.

```{r}

prog2 <- poplr(example3)
str(prog2, max.level = 1)

```

An improvement is highly unlikely in this series.

```{r}

prog2$csr
prog2$csrp

```

In contrast, a deterioration is very likely (p < 0.0001). In the histogram, you can see that a S-score of 176 was only very rarely found in the random permutations of the visual field series.

```{r}

prog2$csl
prog2$cslp

hist(prog2$cstats$cslall)
abline(v = prog2$csl)


```

## Creating pretty reports

Progression reports can be created as pdfs or as interactive reports with shiny.

```{r eval=FALSE, include=TRUE}

# vfspa(example3, file = "test.pdf")

# vfspashiny(example3, file = "test.pdf")

```

# DICOM standard of visual fields

DICOM (Digital Imaging and Communications in Medicine) standards for ophthalmic static perimetry are specified in Supplement 146. However, there are two functions for loading data generated in the DICOMM format created by the Humphrey Field Analyzer (HFA) by Zeiss.

Currently, the data representation in the VisualFields package differs from these standards and data cannot be exported from the package to DICOMM.

# Using a different perimeter

Different manufacturers have different conventions in perimetry. For example, clinicians working with Humphrey Field Analyzers (Carl-Zeiss-Meditec) are often used to report loss of function as negativ values (MD: mean *deviation* of -10dB), while those working with Octopus perimeters (Haag-Streit) often report loss as a positive value (MD: mean *defect* of 10dB). Furthermore, clinicians working with Octopus perimeters often use different grids, even though the 24-2 and 10-2 grids are theoretically available. Usually, fields cannot be directly compared because other setting ($L_max$) are also different and because different algorithms are used.

The VisualField package provided normative data for the Humphrey Field Analyzer but currently not for other perimeters.


The loadoctopus function also imports some normative data from the Octopus perimeter by Haag-Streit, but, as of now, this does not allow full use of the functionality of the visualFields package

For making full use of the visusalField package with other parameters, you ideally need a database of visual fields from a normal reference population, but the creation of normal values with the visualFields package goes beyond the scope of this vignette.

# Advanced topics

## Setting up the environment

A given visual field program has certain properties that remain unchanged during the test. In the visualFields packages these are saved in the *environment*. After setting this environment, you can only analyse data that is consistent with this environment.

The environment contains information on

-   Normative data (nv)
-   Grid (locmap)
-   Graphical parameters used for plotting the data (gpar)
-   Where to find visual field measurements in the tables (locini)

The nv environment variable also contains functions for calculating defects, probabilities and global parameters that can be accessed via the functions stated above.

```{r see current environment variables}

getnv()$info        # current normal values
str(getnv(), 1)

str(getlocmap(), 1)   # current locmap
str(getgpar(), 1)     # current parameters for plotting
getlocini()   # position of the column l1 in the datafram

```

The standard environment assumes a static white-on-white perimetry with a Humphrey perimeter, using a 24-2 grid, a SITA standard algorithm, a stimulus size of Goldman Size III. The stimulus duration and the $L_{max}$ are not explicitly stated in the info.

## Locmaps

```{r locmaps}

default_locmap <- getlocmap()
default_locmap$name
default_locmap$desc

```

A new locmap can be specified manually or selected from the locmaps dataset included in the package.

```{r}

new_locmap <- locmaps$p10d2
setlocmap(new_locmap)

```

Note that some grids spare the blind spot, either on purpose or because they cover only locations central to the blind spot. In this case, locmap\$bs is numeric(0).

```{r}

blind_spot <- getlocmap()$bs

plot(x = new_locmap$coord$x, 
     y = new_locmap$coord$y, 
     type = "point", 
     asp = 1,
     xlim = c(-24, 24),
     ylim = c(-24, 24))
points(x = default_locmap$coord[default_locmap$bs, "x"],
       y = default_locmap$coord[default_locmap$bs, "y"],
       col = "red")

```

Note that for switching to another perimetry program, you need to set all environment variables.

```{r}

setnv(normvals$iowa_PC26_pw)

setlocmap(locmaps$pPC26)

setgpar(gpars$pPC26)

```

## Resetting the enviroment

If you reset the environment, you return to the 24-2 pattern measured with the SITA algorithm on a Humphrey Field Analyser.

```{r}

setdefaults()

```
